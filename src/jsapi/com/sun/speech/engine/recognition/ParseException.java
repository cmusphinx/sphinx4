/* Generated By:JavaCC: Do not edit this line. ParseException.java Version 3.0 */
package com.sun.speech.engine.recognition;

/**
 * This exception is thrown when parse errors are encountered. You can explicitly create objects of this exception type
 * by calling the method generateParseException in the generated parser.
 * <p/>
 * You can modify this class to customize your error reporting mechanisms so long as you retain the public fields.
 */
public class ParseException extends Exception {

    /**
     * This constructor is used by the method "generateParseException" in the generated parser.  Calling this
     * constructor generates a new object of this type with the fields "currentToken", "expectedTokenSequences", and
     * "tokenImage" set. The boolean flag "specialConstructor" is also set to true to indicate that this constructor was
     * used to create this object. This constructor calls its super class with the empty string to force the "toString"
     * method of parent class "Throwable" to print the error message in the form: ParseException: <result of
     * getMessage>
     */
    public ParseException(Token currentTokenVal,
                          int[][] expectedTokenSequencesVal,
                          String[] tokenImageVal
    ) {
        super("");
        specialConstructor = true;
        currentToken = currentTokenVal;
        expectedTokenSequences = expectedTokenSequencesVal;
        tokenImage = tokenImageVal;
    }


    /**
     * The following constructors are for use by you for whatever purpose you can think of.  Constructing the exception
     * in this manner makes the exception behave in the normal way - i.e., as documented in the class "Throwable".  The
     * fields "errorToken", "expectedTokenSequences", and "tokenImage" do not contain relevant information.  The JavaCC
     * generated code does not use these constructors.
     */

    public ParseException() {
        super();
        specialConstructor = false;
    }


    public ParseException(String message) {
        super(message);
        specialConstructor = false;
    }


    /**
     * This variable determines which constructor was used to create this object and thereby affects the semantics of
     * the "getMessage" method (see below).
     */
    protected boolean specialConstructor;

    /**
     * This is the last token that has been consumed successfully.  If this object has been created due to a parse
     * error, the token followng this token will (therefore) be the first error token.
     */
    public Token currentToken;

    /**
     * Each entry in this array is an array of integers.  Each array of integers represents a sequence of tokens (by
     * their ordinal values) that is expected at this point of the parse.
     */
    public int[][] expectedTokenSequences;

    /**
     * This is a reference to the "tokenImage" array of the generated parser within which the parse error occurred.
     * This array is defined in the generated ...Constants interface.
     */
    public String[] tokenImage;


    /**
     * This method has the standard behavior when this object has been created using the standard constructors.
     * Otherwise, it uses "currentToken" and "expectedTokenSequences" to generate a parse error message and returns it.
     * If this object has been created due to a parse error, and you do not catch it (it gets thrown from the parser),
     * then this method is called during the printing of the final stack trace, and hence the correct error message gets
     * displayed.
     */
    public String getMessage() {
        if (!specialConstructor) {
            return super.getMessage();
        }
        StringBuilder expected = new StringBuilder();
        int maxSize = 0;
        for (int[] expectedTokenSequence : expectedTokenSequences) {
            if (maxSize < expectedTokenSequence.length) {
                maxSize = expectedTokenSequence.length;
            }
            for (int index : expectedTokenSequence) {
                expected.append(tokenImage[index]).append(' ');
            }
            if (expectedTokenSequence[expectedTokenSequence.length - 1] != 0) {
                expected.append("...");
            }
            expected.append(eol).append("    ");
        }
        StringBuilder retval = new StringBuilder("Encountered \"");
        Token tok = currentToken.next;
        for (int i = 0; i < maxSize; i++) {
            if (i != 0) retval.append(' ');
            if (tok.kind == 0) {
                retval.append(tokenImage[0]);
                break;
            }
            retval.append(RecognizerUtilities.addEscapes(tok.image));
            tok = tok.next;
        }
        retval.append("\" at line ").append(currentToken.next.beginLine)
            .append(", column ").append(currentToken.next.beginColumn).append('.').append(eol);
        if (expectedTokenSequences.length == 1) {
            retval.append("Was expecting:").append(eol).append("    ");
        } else {
            retval.append("Was expecting one of:").append(eol).append("    ");
        }
        retval.append(expected);
        return retval.toString();
    }


    /** The end of line string for this machine. */
    protected String eol = System.getProperty("line.separator", "\n");

}
