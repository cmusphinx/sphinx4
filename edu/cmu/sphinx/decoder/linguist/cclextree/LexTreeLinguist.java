/*
 * Copyright 1999-2002 Carnegie Mellon University.  
 * Portions Copyright 2002 Sun Microsystems, Inc.  
 * Portions Copyright 2002 Mitsubishi Electronic Research Laboratories.
 * All Rights Reserved.  Use is subject to license terms.
 * 
 * See the file "license.terms" for information on usage and
 * redistribution of this file, and for a DISCLAIMER OF ALL 
 * WARRANTIES.
 *
 */

package edu.cmu.sphinx.decoder.linguist.cclextree;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import edu.cmu.sphinx.decoder.linguist.Grammar;
import edu.cmu.sphinx.decoder.linguist.HMMSearchState;
import edu.cmu.sphinx.decoder.linguist.Linguist;
import edu.cmu.sphinx.decoder.linguist.SearchState;
import edu.cmu.sphinx.decoder.linguist.SearchStateArc;
import edu.cmu.sphinx.decoder.linguist.UnitSearchState;
import edu.cmu.sphinx.decoder.linguist.WordSearchState;
import edu.cmu.sphinx.decoder.linguist.util.HMMPool;
import edu.cmu.sphinx.decoder.linguist.util.LinguistTimer;
import edu.cmu.sphinx.knowledge.acoustic.AcousticModel;
import edu.cmu.sphinx.knowledge.acoustic.HMM;
import edu.cmu.sphinx.knowledge.acoustic.HMMState;
import edu.cmu.sphinx.knowledge.acoustic.HMMStateArc;
import edu.cmu.sphinx.knowledge.acoustic.Unit;
import edu.cmu.sphinx.knowledge.dictionary.Dictionary;
import edu.cmu.sphinx.knowledge.dictionary.Pronunciation;
import edu.cmu.sphinx.knowledge.dictionary.Word;
import edu.cmu.sphinx.knowledge.language.LanguageModel;
import edu.cmu.sphinx.knowledge.language.WordSequence;
import edu.cmu.sphinx.util.LogMath;
import edu.cmu.sphinx.util.SphinxProperties;
import edu.cmu.sphinx.util.Timer;

/**
 * A linguist that can represent large vocabularies efficiently.  This
 * class implements the Linguist interface. The main role of any
 * linguist is to represent the search space for the decoder. The
 * initial state in the search space can be retrieved by a
 * SearchManager via a call to <code> getInitialSearchState</code>.
 * This method returns a SearchState. Successor states can be
 * retrieved via calls to <code>SearchState.getSuccessors().</code>.
 * There are a number of search state subinterfaces that are used to
 * indicate different types of states in the search space:
 *
 * <ul> <li> <b> WordSearchState</b> - represents a word in the search
 * space. 
 * <li> <b> UnitSearchState</b> - represents a unit in the
 * search space
 * <li> <b> HMMSearchState</b> represents an HMM state in the search
 * space
 * </ul>
 *
 * A linguist has a great deal of latitude about the order in which it
 * returns states. For instance a 'flat' linguist may return a
 * WordState at the beginning of a word, while a 'tree' linguist may
 * return WordStates at the ending of a word. Likewise, a linguist may
 * omit certain state types completely (such as a unit state). Some
 * Search Managers may want to know a priori the order in which states
 * will be generated by the linguist. The method
 * <code>getSearchStateOrder</code> can be used to retrieve the order
 * of state returned by the linguist.
 *
 * <p> Depending on the vocabulary size and topology, the search space
 * represented by the linguist may include a very large number of
 * states.  Some linguists will generate the search states
 * dynamically, that is, the object representing a particular state in
 * the search space is not created until it is needed by the
 * SearchManager.  SearchManagers often need to be able to determine if a
 * particular state has been entered before by comparing states.
 * Because SearchStates may be generated dynamically, the
 * <code>SearchState.equals()</code> call (as opposed to the reference
 * equals '==' method) should be used to determine if states are
 * equal. The states returned by the linguist will generally provide
 * very efficient implementations of <code>equals</code> and
 * <code>hashCode</code>. This will allow a SearchManager to maintain
 * collections of states in HashMaps efficiently.
 *
 *
 * <p><b> LexTeeLinguist Characteristics</b>
 *
 * Some characteristics of this linguist:
 * <ul>
 * <li> <b>Dynamic</b> - the linguist generates search states on the fly,
 * greatly reducing the required memory footprint
 * <li> <b> tree topology </b> this linguist represents the search space
 * as an inverted tree. Units near the roots of  word are shared among many
 * different words. These reduces the amount of states that need to be
 * considered during the search.
 * <li> <b> HMM sharing </b> - because of state tying in the acoustic
 * models, it is often the case that triphone units that differ in the
 * right context actually are represented by the same HMM. This linguist
 * recognizes this case and will use a single state to represent the HMM
 * instead of two states.  This can greatly reduce the number of states
 * generated by the linguist.
 * <li> <b> Small-footprint </b>- this linguist uses a few other
 * techniques to reduce the overall footprint of the search space. One
 * technique that is particularly helpful is to share the end word units
 * (where the largest fanout of states occurs) across all of the words.
 * For a 60K word vocabulary, these can result in a reduction in tree
 * nodes of about 2 million to around 3,000.
 * <li> <b> Quick loading </b> - this linguist can compile the
 * search space very quickly. A 60K word vocabulary can be made ready in
 * less than 10 seconds.
 * </ul>
 *
 * This linguist is not a general purpose linguist. It does impose some
 * constraints:
 *
 * <ul>
 *   <li> <b> unit size </b> - this linguist will units that are no
 *   larger than triphones.
 *   <li> <b> n-gram grammars</b> - this linguist will generate the
 *   search space directly from the N-Gram language model. The vocabulary
 *   supported is the intersection of the words found in the language
 *   model and the words that exist in the Dictionary. It is assumed that
 *   all sequences of words in the vocabulary are valid. This linguist
 *   doesn't support arbitrary grammars.
 * </ul>
 *
 * <p><b> Design Notes </b>
 * The following are some notes describing the design of this linguist.
 * They may be helpful to those who want to understand how this linguist
 * works but are not necessary if you are only interested in using this
 * linguist.
 *
* 
 * <p><b> Search Space Representation </b>
 * It has been shown that representing the search space as a tree can
 * greatly reduce the number of active states in a search since the units
 * at the beginnings of words can be shared across multiple words.  For
 * example, with a large vocabulary (60K words), at the end of a word, with a flat
 * representation, we have to provide transitions to the initial state of
 * each possible word. That is 60K transitions.  In a tree based system
 * we need to only provide transitions to each  initial phone (within its
 * context). That is about 1600 transitions. This is a substantial
 * reduction.   Conceptually, this tree consists of a node for each
 * possible initial unit. Each node can have an arbitrary  number of
 * children which can be either unit nodes or word nodes.
 * 
 * <p> This linguist uses the HMMTree class to build and represent the
 * tree. The HMMTree is given the dictionary and language model and builds
 * the lex tree.  Instead of representing the nodes in the tree as  phonemes
 * and words  as is typically done, the HMMTree represents the tree as
 * HMMs and words.  The HMM is essentially a unit within its context.
 * This is typically a triphone (although for some units (such as SIL)
 * it is a simple phone. Representing the nodes as HMM instead of nodes
 * yields a much larger tree, but also has some advantages:
 * 
 * <ul>
 *    <li> Because of state-tying in the acoustic models, many distinct
 *    triphones actually share an HMM.  Representing the nodes as HMMs
 *    allows these shared HMMs to be represented in the tree only once
 *    instead of many times if we representing states as phones or
 *    triphones. This leads to a reduction in the actual number of states
 *    that are considered during a search. Experiments have shown that
 *    this can reduce the required beam by a factor of 2 or 3.
 *    <li> By representing the nodes as HMM, we avoid having to lookup
 *    the HMM for a particular triphone during the search. This is a
 *    modest savings.
 * </ul>
 *
 * There are some disadvantages in representing the tree with HMMs:
 *
 * <ul>
 *    <li> <b> size </b> since HMMs represent units in their context, we
 *    have many more copies of each node. For instance, instead of having
 *    a single unit representing the initial 'd' in the word 'dog' we
 *    would have about 40 HMMs, one for each possible left context.
 *    <li> <b> speed </b> building the much larger HMM tree can take much
 *    more time, since many more nodes are needed to represent the tree.
 *    <li> <b> complexity </b> representing the tree with HMMs is more
 *    complex. There are multiple entry points for each word/unit that
 *    have to be dealt with.
 * </ul>
 *
 * Luckily the size and speed issues can be mitigated (by adding a bit
 * more complexity of course). The bulk of the nodes in the HMM tree are
 * the word ending nodes.  There is a word ending node for each possible
 * right context.  To reduce space, all of the word ending nodes are
 * replaced by a single EndNode.  During the search, the actual hmm nodes
 * for a particular EndNode are generated on request. These sets of hmm
 * nodes can be shared among different word endings, and therefore are
 * cached.  The effect of using this EndNode optimization is to reduce
 * the space required by the tree by about 300mb and the time required to
 * generate the tree from about 60 seconds to about 6 seconds.
 *
 *
 */

public class LexTreeLinguist implements  Linguist {

    /**
     * Prefix for search.Linguist.LexTreeLinguist  SphinxProperties.
     */
    private final static String PROP_PREFIX =
	"edu.cmu.sphinx.decoder.linguist.clextree.LexTreeLinguist.";


    /**
      * A sphinx property that determines whether or not full word
      * histories are used to determine when two states are equal.
      */
    public final static String PROP_FULL_WORD_HISTORIES
        = PROP_PREFIX + "fullWordHistories";

    /**
     * The default value for PROP_FULL_WORD_HISTORIES
     */
    public final static boolean PROP_FULL_WORD_HISTORIES_DEFAULT = true;


    /**
     * The default value for PROP_MAINTAIN_SEPARATE_WORD_RC
     */
    public final static boolean PROP_MAINTAIN_SEPARATE_WORD_RC_DEFAULT = true;


    /**
     * An array of classes that represents the order 
     * in which the states will be returned.
     */
    private final static Class[] searchStateOrder = {
        LexTreeNonEmittingHMMState.class,
        LexTreeWordState.class,
        LexTreeEndWordState.class,
        LexTreeEndUnitState.class,
        LexTreeUnitState.class,
        LexTreeHMMState.class
    };

    private final static SearchStateArc[] EMPTY_ARC = new SearchStateArc[0];

    // just for detailed debugging
    private final boolean tracing = false;

    private SphinxProperties props;
    private LanguageModel languageModel;
    private AcousticModel acousticModel;
    private LogMath logMath;

    private float languageWeight;
    private float logWordInsertionProbability;
    private float logUnitInsertionProbability;
    private float logFillerInsertionProbability;
    private float logSilenceInsertionProbability;
    private float logOne;

    private HMMPool hmmPool;
    private HMMTree hmmTree;
    private Dictionary dictionary;
    
    private boolean fullWordHistories = true;
    private boolean addFillerWords = false;
    private boolean generateUnitStates = false;
    private boolean wantUnigramSmear = true;
    private float unigramSmearWeight = 1.0f;
    private float unigramSmearOffset = .0f;

    private Word sentenceEndWord;
    private Word[] sentenceStartWordArray;

    /**
     * Returns an array of classes that represents the order 
     * in which the states will be returned.
     *
     * @return an array of classes that represents the order 
     *     in which the states will be returned
     */
    public Class[] getSearchStateOrder() {
        return searchStateOrder;
    }


    /**
     * Creates a LexTree linguist associated with the given context
     *
     * @param context the context to associate this linguist with
     * @param languageModel the language model
     * @param dictionary the dictionary to use
     * @param grammar the grammar for this linguist
     * @param models the acoustic model used by this linguist
     */
    public void initialize(String context, 
                           LanguageModel languageModel,
                           Dictionary dictionary,
                           Grammar grammar, 
                           AcousticModel[] models) {
        assert models.length == 1;

        this.props = SphinxProperties.getSphinxProperties(context);
        this.acousticModel = models[0];
        this.logMath = LogMath.getLogMath(context);
        this.languageModel = languageModel;

        this.fullWordHistories =
            props.getBoolean(PROP_FULL_WORD_HISTORIES,
                    PROP_FULL_WORD_HISTORIES_DEFAULT);

        this.wantUnigramSmear  =
            props.getBoolean(PROP_WANT_UNIGRAM_SMEAR,
                    PROP_WANT_UNIGRAM_SMEAR_DEFAULT);


        // System.out.println("LM Max depth is " + languageModel.getMaxDepth());

        this.dictionary = dictionary;

        sentenceEndWord = dictionary.getSentenceEndWord();
        sentenceStartWordArray = new Word[1];
        sentenceStartWordArray[0] = dictionary.getSentenceStartWord();
        
        logOne = logMath.getLogOne();


        logWordInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_WORD_INSERTION_PROBABILITY,
              Linguist.PROP_WORD_INSERTION_PROBABILITY_DEFAULT));

        logSilenceInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_SILENCE_INSERTION_PROBABILITY,
              Linguist.PROP_SILENCE_INSERTION_PROBABILITY_DEFAULT));

        logFillerInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_FILLER_INSERTION_PROBABILITY,
              Linguist.PROP_FILLER_INSERTION_PROBABILITY_DEFAULT));

        logUnitInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_UNIT_INSERTION_PROBABILITY,
              Linguist.PROP_UNIT_INSERTION_PROBABILITY_DEFAULT));

        languageWeight = props.getFloat(PROP_LANGUAGE_WEIGHT,
                                        PROP_LANGUAGE_WEIGHT_DEFAULT);

        addFillerWords = (props.getBoolean (Linguist.PROP_ADD_FILLER_WORDS,
              Linguist.PROP_ADD_FILLER_WORDS_DEFAULT));

        generateUnitStates = 
            (props.getBoolean(Linguist.PROP_GENERATE_UNIT_STATES,
              Linguist.PROP_GENERATE_UNIT_STATES_DEFAULT));

        unigramSmearWeight = props.getFloat(PROP_UNIGRAM_SMEAR_WEIGHT,
             PROP_UNIGRAM_SMEAR_WEIGHT_DEFAULT);


        compileGrammar();

        acousticModel = null;

        if (false) {
            LinguistTimer lt = new LinguistTimer(this, false);
            lt.timeLinguist(10, 500, 1000);
        }
    }

    /**
     * 
     * Called before a recognition
     */
    public void start() {
        // property getters are here in 'start' to allow changing
        // of these properties on the fly

        languageWeight = props.getFloat(PROP_LANGUAGE_WEIGHT,
                                        PROP_LANGUAGE_WEIGHT_DEFAULT);

        logUnitInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_UNIT_INSERTION_PROBABILITY,
              Linguist.PROP_UNIT_INSERTION_PROBABILITY_DEFAULT));

        logWordInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_WORD_INSERTION_PROBABILITY,
              Linguist.PROP_WORD_INSERTION_PROBABILITY_DEFAULT));

        // note that silence and insertion probabilities have the
        // language weight and WIP incorporated into them.

        logSilenceInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_SILENCE_INSERTION_PROBABILITY,
              Linguist.PROP_SILENCE_INSERTION_PROBABILITY_DEFAULT));

        logSilenceInsertionProbability *= languageWeight;
        logSilenceInsertionProbability += logWordInsertionProbability;

        logFillerInsertionProbability = logMath.linearToLog
            (props.getDouble
             (Linguist.PROP_FILLER_INSERTION_PROBABILITY,
              Linguist.PROP_FILLER_INSERTION_PROBABILITY_DEFAULT));

        logFillerInsertionProbability *= languageWeight;
        logFillerInsertionProbability += logWordInsertionProbability;


	languageModel.start();
    }

    /**
     * Called after a recognition
     */
    public void stop() {
	languageModel.stop();
    }

    /**
     * Retrieves the language model for this linguist
     *
     * @return the language model (or null if there is none)
     */
    public LanguageModel getLanguageModel() {
        return languageModel;
    }


    /**
     * retrieves the initial language state
     *
     * @return the initial language state
     */
    public SearchState getInitialSearchState() {
        InitialWordNode node = hmmTree.getInitialNode();
        return new LexTreeWordState(node, node.getParent(),
              WordSequence.getWordSequence(sentenceStartWordArray).trim
               (languageModel.getMaxDepth() - 1), 0f, logOne, logOne);
    }


    /**
     * Compiles the n-gram into a lex tree that is used during the
     * search
     */
    protected void compileGrammar() {
        Timer.start("compile");

        hmmPool = new HMMPool(acousticModel);

        hmmTree = new HMMTree(hmmPool, dictionary, languageModel,
                addFillerWords, languageWeight);

        hmmPool.dumpInfo();

        Timer.stop("compile");
        // Now that we are all done, dump out some interesting
        // information about the process

        Timer.dumpAll();
    }



    /**
     * The LexTreeLinguist returns lanague states to the search
     * manager. This class forms the base implementation for all
     * language states returned.  This LexTreeState keeps track of the
     * probability of entering this state (a language+insertion
     * probability) as well as the unit history. The unit history
     * consists of the LexTree nodes that correspond to the left,
     * center and right contexts.
     *
     *  This is an abstract class, subclasses must implement the
     *  getSuccessorss method.
     */
    class LexTreeState implements SearchState, SearchStateArc {
        private Node node;
        private WordSequence wordSequence;
        float currentSmearTerm;
        float currentSmearProb;

        /**
         * Creates a LexTreeState.
         * @param node the node associated with this state
         *
         * @param wordSequence the history of words up until this point
         *
         */
        LexTreeState(Node node, WordSequence wordSequence, 
                float smearTerm, float smearProb) {
            this.node = node;
            this.wordSequence = wordSequence;
            currentSmearTerm = smearTerm;
            currentSmearProb = smearProb;
        }


        /**
         * Gets the unique signature for this state. The signature
         * building code is slow and should only be used for
         * non-time-critical tasks such as plotting states.
         *
         * @return the signature
         */
        public String getSignature() {
            return "lts-" + node.hashCode() + "-ws-" + wordSequence;
        }


        public float getSmearTerm() {
            return currentSmearTerm;
        }

        public float getSmearProb() {
            return currentSmearProb;
        }


        /**
         * Generate a hashcode for an object
         *
         * @return the hashcode
         */
        public int hashCode() {
            int hashCode = fullWordHistories ? wordSequence.hashCode() * 37 
                                                                       : 37;
            hashCode +=  node.hashCode();
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeState) {
                LexTreeState other = (LexTreeState) o;
                boolean wordSequenceMatch = fullWordHistories ?
                     wordSequence.equals(other.wordSequence) : true;
                return  node == other.node && wordSequenceMatch;
            } else {
                return false;
            }
        }

        /**
         * Gets a successor to this search state
         *
         * @return the sucessor state
         */
         public SearchState  getState() {
             return this;
         }

         /**
          * Gets the composite probability of entering this state
          *
          * @return the log probability
          */
         public float getProbability() {
             return getLanguageProbability() +
                 getAcousticProbability() + getInsertionProbability();
         }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getLanguageProbability() {
             return logOne;
          }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getAcousticProbability() {
             return logOne;
         }

         /**
          * Gets the insertion probability of entering this state
          *
          * @return the log probability
          */
         public float getInsertionProbability() {
             return logOne;
         }



         /**
          * Determines if this is an emitting state
          *
          * @return <code>true</code> if this is an emitting state.
          */
         public boolean isEmitting() {
             return false;
         }

         /**
          * Determines if this is a final state
          *
          * @return <code>true</code> if this is an final state.
          */
         public boolean isFinal() {
             return false;
         }

         /**
          * Gets the hmm tree node representing the unit
          *
          * @return the unit lex node
          */
         protected Node getNode() {
             return node;
         }

         /**
          * Returns the word sequence for this state
          *
          * @return the word sequence
          */
         public WordSequence getWordHistory() {
             return wordSequence;
         }

         public Object getLexState() {
             return node;
         }

         /**
          * Returns the list of successors to this state
          *
          * @return a list of SearchState objects
          */
         public SearchStateArc[] getSuccessors() {
             return getSuccessors(node);
         }

         /**
          * Returns the list of successors to this state
          *
          * @return a list of SearchState objects
          */
         protected SearchStateArc[] getSuccessors(Node theNode) {
	     Collection nodes = theNode.getSuccessors();
             SearchStateArc[] arcs = new SearchStateArc[nodes.size()];
	     Iterator iter = nodes.iterator();
             // System.out.println("Arc: "+ this);
	     for (int i = 0; i < arcs.length; i++) {
		 Node nextNode = (Node) iter.next();
               //  System.out.println("           " + nextNode);
                 if (nextNode instanceof WordNode) {
                     arcs[i] = createWordStateArc(
                             (WordNode) nextNode, (HMMNode) getNode(), this);
                 } else if (nextNode instanceof EndNode) {
                     arcs[i] = createEndUnitArc((EndNode) nextNode, this);
                 } else {
                     arcs[i] = createUnitStateArc((HMMNode)nextNode, this);
                 }
	     }
             return arcs;
         }


         /**
          * Creates a word search state for the given word node
          *
          * @param wordNode the wordNode
          *
          * @return the search state for the wordNode
          */
         protected SearchStateArc createWordStateArc(WordNode wordNode,
                 HMMNode lastUnit, LexTreeState previous) {
            // System.out.println("CWSA " + wordNode + " fup " +  fixupProb);
            float probability = logOne;
            float arcProbability = logOne;
            Word nextWord = wordNode.getWord();
            WordSequence nextWordSequence = wordSequence;
            float smearTerm = previous.getSmearTerm();

            if (!nextWord.isFiller() || nextWord == sentenceEndWord) {
                nextWordSequence  = wordSequence.addWord(nextWord, 
                        languageModel.getMaxDepth());
                probability = languageModel.getProbability(nextWordSequence);
                smearTerm = getSmearTermFromLanguageModel(nextWordSequence);
        // System.out.println("LP " + nextWordSequence + " " + logProbability);
                probability *= languageWeight;
                // subtract off the previously applied smear  probability
                arcProbability = probability - previous.getSmearProb();
            }
            if (nextWord == sentenceEndWord) {
         // System.out.println("LP " + nextWordSequence + " " + logProbability);
                return new LexTreeEndWordState(wordNode, lastUnit,
                    nextWordSequence.trim(languageModel.getMaxDepth() - 1), 
                    smearTerm, logOne, arcProbability);
            } else {
                return new LexTreeWordState(wordNode, lastUnit,
                    nextWordSequence.trim(languageModel.getMaxDepth() - 1), 
                    smearTerm, logOne, arcProbability);
            }
         }



         /**
          * Creates a unit search state for the given unit node
          *
          * @param hmmNode the unit node
          *
          * @return the search state
          */
         SearchStateArc createUnitStateArc(HMMNode hmmNode,
                 LexTreeState previous) {
             SearchStateArc arc;
	     // System.out.println("CUSA " + hmmNode);
             float insertionProbability =
                 calculateInsertionProbability(hmmNode);
             float probability = 
                 getUnigramSmear(hmmNode) + previous.getSmearTerm();
             float arcProbability = probability - previous.getSmearProb();

             // if we want a unit state create it, otherwise
             // get the first hmm state of the unit

             if (generateUnitStates) {
                 arc = new LexTreeUnitState(hmmNode,
                         getWordHistory(), previous.getSmearTerm(), 
                         probability, arcProbability, 
                         insertionProbability);
            } else {
                HMM hmm = hmmNode.getHMM();
                arc = new LexTreeHMMState(hmmNode,
                     getWordHistory(), previous.getSmearTerm(), 
                     probability, hmm.getInitialState(),
                     arcProbability,
                     insertionProbability, logOne, null);
            }
            return arc;
         }

         /**
          * Creates a unit search state for the given unit node
          *
          * @param endNode the unit node
          * @param lastProb the probability of the previus node
          *
          * @return the search state
          */
         SearchStateArc createEndUnitArc(EndNode endNode, 
                 LexTreeState previous) {
             float probability = 
                 getUnigramSmear(endNode) + previous.getSmearTerm();
             float arcProbability = probability - previous.getSmearProb();
             float insertionProbability =
                 calculateInsertionProbability(endNode);
             return  new LexTreeEndUnitState(endNode, getWordHistory(), 
                     previous.getSmearTerm(), probability,
                     arcProbability, insertionProbability);
         }

         /**
          * Returns the string representation of this object
          *
          * @return the string representation
          */
        public String toString() {
            return "lt-" + node + " " + getProbability() +
                   "{" + wordSequence + "}" ;
        }

       /**
        * Returns a pretty version of the string representation 
        * for this object
        *
        * @return a pretty string
        */
       public String toPrettyString() {
           return toString();
       }
    }

    /**
     * Represents a unit in the search space
     */
    public class LexTreeEndUnitState extends LexTreeState 
                implements UnitSearchState {

        float logLanguageProbability;
        float logInsertionProbability;
        /**
         * Constructs a LexTreeUnitState
         *
         *
         * @param wordSequence the history of words
         */
        LexTreeEndUnitState(EndNode endNode, WordSequence
                wordSequence, float smearTerm, float smearProb,
                float languageProbability, float insertionProbability) {
            super(endNode, wordSequence, smearTerm, smearProb);
            logLanguageProbability = languageProbability;
            logInsertionProbability = insertionProbability;
            // System.out.println("LTEUS " + logLanguageProbability + " " + logInsertionProbability);
        }

        /**
         * Returns the base unit assciated with this state
         *
         * @return the base unit
         */
        public Unit getUnit() {
            return getEndNode().getBaseUnit();
        }

        /**
         * Generate a hashcode for an object
         *
         * @return the hashcode
         */
        public int hashCode() {
            return super.hashCode() * 17 + 423;
        }

         /**
          * Gets the acoustic  probability of entering this state
          *
          * @return the log probability
          */
         public float getInsertionProbability() {
             return logInsertionProbability;
         }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getLanguageProbability() {
             return logLanguageProbability;
         }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeEndUnitState) {
                LexTreeEndUnitState other = (LexTreeEndUnitState) o;
                return  super.equals(o);
            } else {
                return false;
            }
        }

        /**
         * Returns the unit node for this state
         *
         * @return the unit node
         */
        private EndNode getEndNode() {
            return (EndNode) getNode();
        }


       /**
        * Returns the list of successors to this state
        *
        * @return a list of SearchState objects
        */
       public SearchStateArc[] getSuccessors() {
          HMMNode[] nodes = getHMMNodes(getEndNode());
          SearchStateArc[] arcs = new SearchStateArc[nodes.length];

          if (generateUnitStates) {
              for (int i = 0; i < nodes.length; i++) {
                  arcs[i] = new LexTreeUnitState(nodes[i], getWordHistory(), 
                      getSmearTerm(), getSmearProb(),
                      logOne, logOne, this.getNode());
              }
          } else {
              for (int i = 0; i < nodes.length; i++) {
                    HMM hmm = nodes[i].getHMM();
                    arcs[i] = new LexTreeHMMState(nodes[i],
                         getWordHistory(), getSmearTerm(), getSmearProb(),
                         hmm.getInitialState(), logOne,
                         logOne, logOne, this.getNode());
              }
          }
          return arcs;
       }


       public String toString() {
           return super.toString() + " EndUnit";
       }
    }

    /**
     * Represents a unit in the search space
     */
    public class LexTreeUnitState extends LexTreeState 
                implements UnitSearchState {

        private float logInsertionProbability;
        private float logLanguageProbability;
        private Node parentNode = null;
        private int hashCode = -1;

        /**
         * Constructs a LexTreeUnitState
         *
         *
         * @param wordSequence the history of words
         */
        LexTreeUnitState(HMMNode hmmNode, 
               WordSequence wordSequence, float smearTerm, float smearProb,
               float languageProbability, float insertionProbability) {
            this(hmmNode, wordSequence, smearTerm, smearProb,
                    languageProbability, insertionProbability, null);
        }

        /**
         * Constructs a LexTreeUnitState
         *
         *
         * @param wordSequence the history of words
         */
        LexTreeUnitState(HMMNode hmmNode, 
               WordSequence wordSequence, float smearTerm, float smearProb,
               float languageProbability, float insertionProbability,
               Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb);
            this.logInsertionProbability = insertionProbability;
            this.logLanguageProbability = languageProbability;
            this.parentNode = parentNode;
        }

        /**
         * Returns the base unit assciated with this state
         *
         * @return the base unit
         */
        public Unit getUnit() {
            return getHMMNode().getBaseUnit();
        }

        /**
         * Generate a hashcode for an object
         *
         * @return the hashcode
         */
        public int hashCode() {
            if (hashCode == -1) {
                hashCode = super.hashCode() * 17 + 421;
                if (parentNode != null) {
                    hashCode *=432;
                    hashCode += parentNode.hashCode();
                }
            }
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeUnitState) {
                LexTreeUnitState other = (LexTreeUnitState) o;
                return  super.equals(o) && parentNode == other.parentNode;
            } else {
                return false;
            }
        }

        /**
         * Returns the unit node for this state
         *
         * @return the unit node
         */
        private HMMNode getHMMNode() {
            return (HMMNode) getNode();
        }

         /**
          * Returns the list of successors to this state
          *
          * @return a list of SearchState objects
          */
         public SearchStateArc[] getSuccessors() {
            SearchStateArc[] arcs = new SearchStateArc[1];
            HMM hmm = getHMMNode().getHMM();
            arcs[0] = new LexTreeHMMState(getHMMNode(),
                 getWordHistory(), getSmearTerm(), getSmearProb(),
                 hmm.getInitialState(),
                 logOne, logOne, logOne, parentNode);
            return arcs;
         }

         public String toString() {
             return super.toString() + " unit";
         }

         /**
          * Gets the acoustic  probability of entering this state
          *
          * @return the log probability
          */
         public float getInsertionProbability() {
             return logInsertionProbability;
         }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getLanguageProbability() {
             return logLanguageProbability;
         }
    }

    /**
     * Represents a HMM state in the search space
     */
    public class LexTreeHMMState extends LexTreeState 
            implements HMMSearchState {
    
        private HMMState hmmState;
        private float logLanguageProbability;
        private float logInsertionProbability;
        private float logAcousticProbability;
        private Node parentNode;
        int hashCode = -1;

        /**
         * Constructs a LexTreeHMMState
         *
         * 
         * @param hmmNode the hmm state associated with this unit
         *
         * @param wordSequence the word history 
         *
         * @param languageProbability the probability of the transition
         * @param insertionProbability the probability of the transition
         * @param acousticProbability the probability of the transition
         * occuring
         */
        LexTreeHMMState(HMMNode hmmNode, WordSequence wordSequence, 
                float smearTerm, float smearProb,
               HMMState hmmState, float languageProbability,
	       float insertionProbability,
               float acousticProbability, Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb);
            this.hmmState = hmmState;
            this.parentNode = parentNode;
            this.logLanguageProbability = languageProbability;
            this.logInsertionProbability = insertionProbability;
            this.logAcousticProbability = acousticProbability;
        }

        /**
         * Gets the ID for this state
         *
         * @return the ID
         */
        public String getSignature() {
            return super.getSignature() + "-HMM-" + hmmState.getState();
        }

        /**
         * returns the hmm state associated with this state
         *
         * @return the hmm state
         */
        public HMMState getHMMState() {
            return hmmState;
        }

        /**
         * Generate a hashcode for an object
         *
         * @return the hashcode
         */
        public int hashCode() {
            if (hashCode == -1) {
                hashCode =  super.hashCode() * 29 + (hmmState.getState() + 1);
                if (parentNode != null) {
                    hashCode *=377;
                    hashCode += parentNode.hashCode();
                }
            }
            return hashCode;
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeHMMState) {
                LexTreeHMMState other = (LexTreeHMMState) o;
                return super.equals(o) && hmmState == other.hmmState
                    && parentNode == other.parentNode ;
            } else {
                return false;
            }
        }

         /**
          * Gets the acoustic  probability of entering this state
          *
          * @return the log probability
          */
         public float getAcousticProbability() {
             return logAcousticProbability;
         }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getLanguageProbability() {
             return logLanguageProbability;
         }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getInsertionProbability() {
             return logInsertionProbability;
         }

        /**
         * Retreives the set of successors for this state
         *
         * @return the list of sucessor states
         */
        public SearchStateArc[] getSuccessors() {
            SearchStateArc[] nextStates = null;

            // if this is an exit state, we are transitioning to a
            // new unit or to a word end.

            if (hmmState.isExitState()) {
                if (parentNode == null) {
                    nextStates =  super.getSuccessors();
                } else {
                    nextStates = super.getSuccessors(parentNode);
                }
            } else {
                // The current hmm state is not an exit state, so we
                // just go through the next set of successors

                HMMStateArc[] arcs = hmmState.getSuccessors();
                nextStates = new SearchStateArc[arcs.length];
                for (int i = 0; i < arcs.length; i++) {
                    HMMStateArc arc = arcs[i];
                    if (arc.getHMMState().isEmitting()) {
                        // if its a self loop and the prob. matches
                        // reuse the state
                        if (arc.getHMMState()  == hmmState &&
                            logAcousticProbability == arc.getLogProbability()) {
                            nextStates[i] = this;
                        } else {
                            nextStates[i] = new LexTreeHMMState(
                                (HMMNode) getNode(), getWordHistory(),
                                getSmearTerm(), getSmearProb(),
                                arc.getHMMState(), logOne, logOne,
                                arc.getLogProbability(), parentNode);
                        }
                    } else {
                        nextStates[i] = new LexTreeNonEmittingHMMState(
                            (HMMNode) getNode(), getWordHistory(),
                            getSmearTerm(), getSmearProb(),
                            arc.getHMMState(),
                            arc.getLogProbability(), parentNode);
                    }
                }
            }
            return nextStates;
        }

         /**
          * Determines if this is an emitting state
          */
         public boolean isEmitting() {
             return hmmState.isEmitting();
         }

         public String toString() {
             return super.toString() + " hmm:" +  hmmState;
         }
    }

    /**
     * Represents a non emitting hmm state
     */
    public class LexTreeNonEmittingHMMState extends LexTreeHMMState {
        
        /**
         * Constructs a NonEmittingLexTreeHMMState
         * 
         * @param hmmState the hmm state associated with this unit
         *
         * @param wordSequence the word history 
         *
         * @param probability the probability of the transition
         * occuring
         */
        LexTreeNonEmittingHMMState(HMMNode hmmNode, 
               WordSequence wordSequence, float smearTerm, float smearProb,
               HMMState hmmState, float probability, Node parentNode) {
            super(hmmNode, wordSequence, smearTerm, smearProb,
                    hmmState, logOne, logOne, 
                    probability, parentNode);
        }
    }




    /**
     * Represents a word state in the search space
     */
    public class LexTreeWordState extends LexTreeState 
        implements WordSearchState {

        private HMMNode lastNode;
        private float logLanguageProbability;

        /**
         * Constructs a LexTreeWordState
         *
         * @param wordNode the word node
         *
         * @param wordSequence the sequence of words
         * triphone context
         * 
         * @param logProbability the probability of this word occuring
         *
         */
        LexTreeWordState(WordNode wordNode, HMMNode lastNode,
               WordSequence wordSequence, float smearTerm,  float smearProb,
               float logProbability) {

            super(wordNode, wordSequence, smearTerm, smearProb);
            // System.out.println("LTWS " + wordSequence);
            this.lastNode = lastNode;
            this.logLanguageProbability = logProbability;
        }

        /**
         * Gets the word pronunciation for this state
         *
         * @return the pronunciation for this word
         */
        public Pronunciation getPronunciation() {
            return ((WordNode) getNode()).getPronunciation();
        }

         /**
          * Determines if this is a final state
          *
          * @return <code>true</code> if this is an final state.
          */
         public boolean isFinal() {
             return getPronunciation().getWord().equals(sentenceEndWord);
         }

        /**
         * Generate a hashcode for an object
         *
         * @return the hashcode
         */
        public int hashCode() {
            return super.hashCode() * 41 + lastNode.hashCode();
        }

        /**
         * Gets the unique signature for this state. The signature
         * building code is slow and should only be used for
         * non-time-critical tasks such as plotting states.
         *
         * @return the signature
         */
        public String getSignature() {
            return super.getSignature() + "-ln-" + lastNode.hashCode();
        }

        /**
         * Determines if the given object is equal to this object
         * 
         * @param o the object to test
         * @return <code>true</code> if the object is equal to this
         */
        public boolean equals(Object o) {
            if (o == this) {
                return true;
            } else if (o instanceof LexTreeWordState) {
                LexTreeWordState other = (LexTreeWordState) o;
                return  super.equals(o) && lastNode == other.lastNode;
            } else {
                return false;
            }
        }

         /**
          * Gets the language probability of entering this state
          *
          * @return the log probability
          */
         public float getLanguageProbability() {
             return logLanguageProbability;
          }

         /**
          * Returns the list of successors to this state
          *
          * @return a list of SearchState objects
          */
         public SearchStateArc[] getSuccessors() {
             SearchStateArc[] arcs = EMPTY_ARC;
             WordNode wordNode = (WordNode) getNode();

             if (wordNode.getWord() != sentenceEndWord) {
                 int index = 0;
                 List list = new ArrayList();
                 Unit[] rc  = lastNode.getRC();
                 Unit left = wordNode.getLastUnit();

                 for (int i = 0; i < rc.length; i++) {
                     Collection epList = hmmTree.getEntryPoint(left, rc[i]);
                     list.addAll(epList);
                 }

                 // add a link to every possible entry point as well
                 // as link to the </s> node
                 arcs = new SearchStateArc[list.size() + 1];
                 for (Iterator i = list.iterator(); i.hasNext(); ) {
                     HMMNode node = (HMMNode) i.next();
                     arcs[index++] = createUnitStateArc(node, this);
                 }

                 // now add the link to the end of sentence arc:

                 arcs[index++] =
                     createWordStateArc(hmmTree.getSentenceEndWordNode(),
                             lastNode, this);
             }
             return arcs;
         }
    }

    /**
     * Represents the final end of utterance word
     */
    public class LexTreeEndWordState extends LexTreeWordState 
        implements WordSearchState {

        /**
         * Constructs a LexTreeWordState
         *
         * @param wordNode the word node
         *
         * @param lastNode the previous word node
         *
         * @param wordSequence the sequence of words
         * triphone context
         * 
         * @param logProbability the probability of this word occuring
         *
         */
        LexTreeEndWordState(WordNode wordNode, HMMNode lastNode,
               WordSequence wordSequence, float smearTerm, 
               float smearProb, float logProbability) {
            super(wordNode, lastNode, wordSequence, smearTerm,
                    smearProb, logProbability);
        }

    }


    /**
     * Determines the insertion probability for the given unit lex
     * node
     *
     * @param unitNode the unit lex node
     *
     * @return the insertion probability
     */
    private float calculateInsertionProbability(UnitNode unitNode) {
        float logInsertionProbability = logUnitInsertionProbability;
        if (unitNode.getBaseUnit().isSilence()) {
            logInsertionProbability = logSilenceInsertionProbability;
        } else if (unitNode.getBaseUnit().isFiller()) {
            logInsertionProbability = logFillerInsertionProbability;
        } else if (unitNode.getPosition().isWordBeginning()) {
            logInsertionProbability += logWordInsertionProbability;
        }
        return logInsertionProbability;
    }

    /**
     * Retrieves the unigram smear from the given node
     *
     * @return the unigram smear
     */
    private float getUnigramSmear(Node node) {
        float prob;
        if (wantUnigramSmear) {
            prob = node.getUnigramProbability() * unigramSmearWeight;
        } else {
            prob = logOne;
        }
        return prob;
    }


    /**
     * Returns the smear term for the given word sequence
     *
     * @param ws the word sequence
     * @return the smear term for the word sequence
     */
    private float getSmearTermFromLanguageModel(WordSequence ws) {
        return languageModel.getSmear(ws);
    }


    /**
     * Gets the  set of hmm nodes associated with the given end node
     *
     * @param endNode the end node
     *
     * @return an array of associated hmm nodes
     */
    private HMMNode[] getHMMNodes(EndNode endNode) {
        return hmmTree.getHMMNodes(endNode);
    }
}

